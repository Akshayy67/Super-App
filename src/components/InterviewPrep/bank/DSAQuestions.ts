import { Question } from "../InterviewSubjects";

// Collection of 75 most asked DSA interview questions
export const dsaQuestions: Question[] = [
  // Array Questions
  {
    id: "dsa-1",
    question: "Find two numbers in an array that add up to a target sum (Two Sum)",
    category: "arrays",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use a hash map to store numbers and their indices. For each element, check if (target - current element) exists in the hash map. If yes, return the indices. If no, add current element to hash map. Time complexity: O(n), Space complexity: O(n).",
    tips: [
      "Consider using a hash map for O(1) lookup",
      "Handle edge cases like duplicate numbers",
      "Discuss brute force vs optimized approach"
    ],
    tags: ["arrays", "hash-map", "two-pointers"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-2",
    question: "Find the maximum subarray sum (Kadane's Algorithm)",
    category: "arrays",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use Kadane's algorithm: maintain a running sum, reset to 0 when it becomes negative, and track the maximum sum seen so far. The key insight is that a negative prefix doesn't help maximize the sum. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Explain the intuition behind Kadane's algorithm",
      "Handle all negative numbers case",
      "Discuss dynamic programming approach"
    ],
    tags: ["arrays", "dynamic-programming", "kadane"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-3",
    question: "Rotate an array to the right by k steps",
    category: "arrays",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Three approaches: 1) Extra space: create new array with elements at correct positions. 2) Reverse approach: reverse entire array, then reverse first k elements, then reverse remaining elements. 3) Cyclic replacements: move elements to their final positions in cycles. Reverse approach is most elegant with O(1) space.",
    tips: [
      "Consider k > array length case",
      "Discuss in-place vs extra space solutions",
      "Explain the reverse method step by step"
    ],
    tags: ["arrays", "rotation", "reverse"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-4",
    question: "Remove duplicates from sorted array in-place",
    category: "arrays",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use two pointers: one for reading (fast) and one for writing (slow). When fast pointer finds a new unique element, copy it to slow pointer position and increment slow. Return slow + 1 as the new length. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Emphasize in-place modification",
      "Handle empty array edge case",
      "Explain why two pointers work here"
    ],
    tags: ["arrays", "two-pointers", "in-place"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-5",
    question: "Find the intersection of two arrays",
    category: "arrays",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Two approaches: 1) Hash set: put one array in a set, iterate through second array and check membership. 2) Sort both arrays and use two pointers. Hash set approach is generally better with O(n+m) time complexity. Handle duplicates by using a frequency map if needed.",
    tips: [
      "Consider if arrays are sorted",
      "Handle duplicate elements properly",
      "Discuss space-time tradeoffs"
    ],
    tags: ["arrays", "hash-set", "two-pointers"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // String Questions
  {
    id: "dsa-6",
    question: "Check if a string is a valid palindrome",
    category: "strings",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use two pointers from start and end, moving towards center. Compare characters after converting to lowercase and skipping non-alphanumeric characters. Return false if any mismatch found. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Handle case sensitivity and special characters",
      "Consider recursive vs iterative approach",
      "Discuss preprocessing vs on-the-fly filtering"
    ],
    tags: ["strings", "two-pointers", "palindrome"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-7",
    question: "Find the longest substring without repeating characters",
    category: "strings",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use sliding window technique with a hash set. Expand window by moving right pointer and adding characters to set. When duplicate found, shrink window from left until duplicate is removed. Track maximum window size. Time complexity: O(n), Space complexity: O(min(m,n)) where m is charset size.",
    tips: [
      "Explain sliding window concept clearly",
      "Handle empty string edge case",
      "Discuss optimization using character indices"
    ],
    tags: ["strings", "sliding-window", "hash-set"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-8",
    question: "Implement string matching algorithm (KMP or naive)",
    category: "strings",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Naive approach: check every position in text for pattern match, O(nm) time. KMP algorithm: preprocess pattern to create LPS (Longest Proper Prefix which is also Suffix) array, then use it to skip characters during matching, achieving O(n+m) time complexity. KMP avoids redundant comparisons.",
    tips: [
      "Explain LPS array construction",
      "Compare naive vs KMP approaches",
      "Discuss other algorithms like Rabin-Karp"
    ],
    tags: ["strings", "pattern-matching", "kmp"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-9",
    question: "Group anagrams together",
    category: "strings",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use a hash map where key is the sorted string (canonical form) and value is list of anagrams. For each string, sort its characters to get the key, then add the original string to the corresponding list. Time complexity: O(n * k log k) where k is average string length.",
    tips: [
      "Consider using character frequency as key",
      "Handle empty strings and single characters",
      "Discuss space-time tradeoffs"
    ],
    tags: ["strings", "hash-map", "sorting"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-10",
    question: "Find all permutations of a string",
    category: "strings",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use backtracking: for each position, try all unused characters, recursively generate permutations for remaining positions, then backtrack. Alternative: iterative approach using next permutation algorithm. Time complexity: O(n! * n), Space complexity: O(n) for recursion stack.",
    tips: [
      "Explain backtracking concept clearly",
      "Handle duplicate characters case",
      "Discuss iterative vs recursive approaches"
    ],
    tags: ["strings", "backtracking", "permutations"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Linked List Questions
  {
    id: "dsa-11",
    question: "Reverse a linked list (iterative and recursive)",
    category: "linked-lists",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Iterative: Use three pointers (prev, current, next). For each node, store next, reverse current's link to prev, move pointers forward. Recursive: reverse rest of list first, then fix current node's links. Both have O(n) time, iterative uses O(1) space, recursive uses O(n) space.",
    tips: [
      "Draw the pointer movements",
      "Handle empty list and single node cases",
      "Compare iterative vs recursive space complexity"
    ],
    tags: ["linked-lists", "pointers", "recursion"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-12",
    question: "Detect cycle in a linked list (Floyd's Algorithm)",
    category: "linked-lists",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use Floyd's cycle detection (tortoise and hare): two pointers moving at different speeds. Slow moves one step, fast moves two steps. If there's a cycle, they'll meet inside the cycle. If fast reaches null, no cycle exists. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Explain why fast and slow pointers meet",
      "Discuss finding the start of cycle",
      "Handle edge cases like empty list"
    ],
    tags: ["linked-lists", "cycle-detection", "two-pointers"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-13",
    question: "Merge two sorted linked lists",
    category: "linked-lists",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use a dummy node to simplify edge cases. Compare heads of both lists, attach smaller node to result, advance that pointer. Continue until one list is exhausted, then attach remaining list. Time complexity: O(n+m), Space complexity: O(1) for iterative, O(n+m) for recursive.",
    tips: [
      "Use dummy node to avoid edge case handling",
      "Consider recursive vs iterative approach",
      "Handle null lists properly"
    ],
    tags: ["linked-lists", "merge", "sorting"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-14",
    question: "Find the middle node of a linked list",
    category: "linked-lists",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use two pointers (slow and fast). Slow moves one step, fast moves two steps. When fast reaches end, slow will be at middle. For even length lists, this gives the second middle node. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Handle even vs odd length lists",
      "Consider if you need first or second middle for even length",
      "Explain the mathematical reasoning"
    ],
    tags: ["linked-lists", "two-pointers", "middle"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-15",
    question: "Remove nth node from end of linked list",
    category: "linked-lists",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use two pointers with n+1 gap between them. Move first pointer n+1 steps ahead, then move both pointers until first reaches end. Second pointer will be just before the node to remove. Use dummy node to handle edge case of removing head. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Use dummy node for edge cases",
      "Explain the gap calculation",
      "Handle removing the head node"
    ],
    tags: ["linked-lists", "two-pointers", "removal"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Stack and Queue Questions
  {
    id: "dsa-16",
    question: "Implement a stack using queues",
    category: "stacks-queues",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Two approaches: 1) Make push expensive: use two queues, for push operation move all elements from q1 to q2, add new element to q1, move all back. 2) Make pop expensive: use one queue, for pop rotate all elements except last one to back of queue. First approach is more intuitive.",
    tips: [
      "Compare both approaches",
      "Discuss time complexities of operations",
      "Consider using deque for optimization"
    ],
    tags: ["stacks", "queues", "implementation"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-17",
    question: "Valid parentheses checker",
    category: "stacks-queues",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use a stack to track opening brackets. For each character: if opening bracket, push to stack; if closing bracket, check if stack is empty or top doesn't match - return false; otherwise pop. Return true if stack is empty at end. Time complexity: O(n), Space complexity: O(n).",
    tips: [
      "Handle different types of brackets",
      "Consider edge cases like empty string",
      "Explain why stack is perfect for this problem"
    ],
    tags: ["stacks", "strings", "validation"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-18",
    question: "Design a min stack with O(1) getMin operation",
    category: "stacks-queues",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Two approaches: 1) Use two stacks - one for data, one for minimums. Push to min stack only if new element ≤ current min. 2) Use single stack storing pairs (value, current_min). Both maintain O(1) for all operations including getMin.",
    tips: [
      "Compare space efficiency of both approaches",
      "Handle duplicate minimum values",
      "Discuss when to push/pop from min stack"
    ],
    tags: ["stacks", "design", "optimization"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-19",
    question: "Implement queue using stacks",
    category: "stacks-queues",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use two stacks: input and output. For enqueue, push to input stack. For dequeue, if output stack is empty, move all elements from input to output, then pop from output. This amortizes the cost, making dequeue O(1) amortized. Time complexity: O(1) amortized for both operations.",
    tips: [
      "Explain amortized analysis",
      "Consider when to transfer between stacks",
      "Handle empty queue edge case"
    ],
    tags: ["stacks", "queues", "amortized"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-20",
    question: "Largest rectangle in histogram",
    category: "stacks-queues",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Use a stack to store indices of histogram bars. For each bar, while stack is not empty and current bar is smaller than bar at stack top, calculate area with stack top as smallest bar. The width is determined by current index and the index below stack top. Time complexity: O(n), Space complexity: O(n).",
    tips: [
      "Explain why stack stores indices, not values",
      "Walk through the area calculation",
      "Handle edge cases like empty histogram"
    ],
    tags: ["stacks", "histogram", "area"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Tree Questions
  {
    id: "dsa-21",
    question: "Binary tree inorder, preorder, and postorder traversal",
    category: "trees",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Inorder (Left-Root-Right): useful for BST to get sorted order. Preorder (Root-Left-Right): useful for copying tree. Postorder (Left-Right-Root): useful for deleting tree. Can be implemented recursively or iteratively using stack. Recursive is simpler, iterative uses explicit stack.",
    tips: [
      "Explain the order of visits for each traversal",
      "Discuss recursive vs iterative implementations",
      "Mention practical use cases for each traversal"
    ],
    tags: ["trees", "traversal", "recursion"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-22",
    question: "Maximum depth/height of a binary tree",
    category: "trees",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Recursive approach: if node is null, return 0; otherwise return 1 + max(height of left subtree, height of right subtree). Iterative approach: use level-order traversal (BFS) and count levels. Time complexity: O(n), Space complexity: O(h) where h is height.",
    tips: [
      "Clarify difference between depth and height",
      "Consider balanced vs unbalanced trees",
      "Discuss BFS vs DFS approaches"
    ],
    tags: ["trees", "height", "recursion"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-23",
    question: "Check if a binary tree is balanced",
    category: "trees",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "A balanced tree has height difference of at most 1 between left and right subtrees for every node. Recursive approach: for each node, check if left and right subtrees are balanced and their height difference is ≤ 1. Optimize by returning height and balance status together to avoid recalculation.",
    tips: [
      "Define what balanced means clearly",
      "Optimize to avoid redundant height calculations",
      "Consider bottom-up vs top-down approaches"
    ],
    tags: ["trees", "balanced", "height"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-24",
    question: "Lowest Common Ancestor (LCA) in a binary tree",
    category: "trees",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Recursive approach: if current node is null or equals either target node, return current node. Recursively find LCA in left and right subtrees. If both return non-null, current node is LCA. If only one returns non-null, that's the LCA. Time complexity: O(n), Space complexity: O(h).",
    tips: [
      "Handle case where one node is ancestor of another",
      "Consider BST vs general binary tree",
      "Discuss iterative approach using parent pointers"
    ],
    tags: ["trees", "lca", "recursion"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-25",
    question: "Binary tree level order traversal",
    category: "trees",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use BFS with a queue. Start with root in queue. For each level, process all nodes currently in queue (use queue size to track level boundary). Add children of processed nodes to queue for next level. This naturally groups nodes by level. Time complexity: O(n), Space complexity: O(w) where w is maximum width.",
    tips: [
      "Explain how to track level boundaries",
      "Consider returning levels separately vs flattened",
      "Discuss space complexity in terms of tree width"
    ],
    tags: ["trees", "bfs", "level-order"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Binary Search Tree Questions
  {
    id: "dsa-26",
    question: "Validate if a binary tree is a valid BST",
    category: "trees",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use bounds checking: for each node, ensure its value is within valid range (min, max). For left child, max becomes current node's value. For right child, min becomes current node's value. Alternative: inorder traversal should produce sorted sequence. Time complexity: O(n), Space complexity: O(h).",
    tips: [
      "Explain why checking only immediate children isn't enough",
      "Handle duplicate values case",
      "Compare bounds vs inorder approaches"
    ],
    tags: ["trees", "bst", "validation"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-27",
    question: "Find kth smallest element in BST",
    category: "trees",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use inorder traversal (gives sorted order in BST). Keep a counter, return when counter reaches k. Can be done recursively or iteratively with stack. For frequent queries, augment BST nodes with subtree sizes for O(h) lookup. Time complexity: O(h + k), Space complexity: O(h).",
    tips: [
      "Explain why inorder works for BST",
      "Consider optimization for multiple queries",
      "Discuss early termination"
    ],
    tags: ["trees", "bst", "inorder"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-28",
    question: "Convert sorted array to balanced BST",
    category: "trees",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use divide and conquer: pick middle element as root, recursively build left subtree from left half and right subtree from right half. This ensures the tree is balanced since we're always picking the middle element. Time complexity: O(n), Space complexity: O(log n) for recursion stack.",
    tips: [
      "Explain why middle element ensures balance",
      "Handle even vs odd array lengths",
      "Discuss the recursive structure"
    ],
    tags: ["trees", "bst", "divide-conquer"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Graph Questions
  {
    id: "dsa-29",
    question: "Implement Depth-First Search (DFS) in a graph",
    category: "graphs",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "DFS explores as far as possible along each branch before backtracking. Can be implemented recursively or iteratively with a stack. Recursive: mark current node visited, recursively visit all unvisited neighbors. Iterative: use explicit stack, push start node, while stack not empty pop node and visit unvisited neighbors. Time complexity: O(V + E), Space complexity: O(V).",
    tips: [
      "Explain recursive vs iterative implementations",
      "Discuss visited array importance",
      "Compare with BFS characteristics"
    ],
    tags: ["graphs", "dfs", "traversal"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-30",
    question: "Implement Breadth-First Search (BFS) in a graph",
    category: "graphs",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "BFS explores all neighbors at current depth before moving to next depth level. Use a queue: start with initial node in queue, while queue not empty, dequeue node, visit it, and enqueue all unvisited neighbors. Naturally finds shortest path in unweighted graphs. Time complexity: O(V + E), Space complexity: O(V).",
    tips: [
      "Explain level-by-level exploration",
      "Discuss shortest path property",
      "Compare queue vs stack data structures"
    ],
    tags: ["graphs", "bfs", "shortest-path"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-31",
    question: "Detect cycle in a directed graph",
    category: "graphs",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use DFS with three colors: white (unvisited), gray (visiting), black (visited). During DFS, if we encounter a gray node, there's a back edge indicating a cycle. Gray nodes represent the current path in recursion stack. Time complexity: O(V + E), Space complexity: O(V).",
    tips: [
      "Explain the three-color approach",
      "Differentiate from undirected graph cycle detection",
      "Discuss topological sorting relation"
    ],
    tags: ["graphs", "cycle-detection", "dfs"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-32",
    question: "Find shortest path in weighted graph (Dijkstra's Algorithm)",
    category: "graphs",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Dijkstra's algorithm finds shortest path from source to all vertices in weighted graph with non-negative weights. Use a priority queue (min-heap) and distance array. Initialize source distance to 0, others to infinity. While queue not empty, extract minimum distance vertex, relax all its neighbors by updating their distances if shorter path found. Time complexity: O((V + E) log V) with binary heap.",
    tips: [
      "Explain relaxation process",
      "Discuss why negative weights break the algorithm",
      "Compare with Bellman-Ford for negative weights"
    ],
    tags: ["graphs", "shortest-path", "dijkstra"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-33",
    question: "Topological sorting of a directed acyclic graph",
    category: "graphs",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Two approaches: 1) DFS-based: perform DFS, add nodes to result in post-order (when finishing), then reverse result. 2) Kahn's algorithm: use in-degree array, start with nodes having 0 in-degree, process them and reduce in-degree of neighbors. Both produce valid topological ordering. Time complexity: O(V + E).",
    tips: [
      "Explain applications like course scheduling",
      "Discuss cycle detection as prerequisite",
      "Compare DFS vs Kahn's approaches"
    ],
    tags: ["graphs", "topological-sort", "dag"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Dynamic Programming Questions
  {
    id: "dsa-34",
    question: "Fibonacci sequence using dynamic programming",
    category: "dynamic-programming",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Three approaches: 1) Recursive with memoization: store computed values in array/map. 2) Bottom-up tabulation: build from base cases up. 3) Space-optimized: only keep last two values. Bottom-up with space optimization is best: use two variables to track previous two Fibonacci numbers. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Compare recursive vs iterative approaches",
      "Explain memoization benefits",
      "Discuss space optimization technique"
    ],
    tags: ["dynamic-programming", "fibonacci", "optimization"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-35",
    question: "0/1 Knapsack problem",
    category: "dynamic-programming",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use 2D DP table where dp[i][w] represents maximum value achievable with first i items and weight limit w. For each item, choose max of: including item (value + dp[i-1][w-weight]) or excluding item (dp[i-1][w]). Can optimize space to O(w) using 1D array. Time complexity: O(n*W), Space complexity: O(W) optimized.",
    tips: [
      "Explain the choice at each step",
      "Discuss space optimization technique",
      "Compare with fractional knapsack (greedy)"
    ],
    tags: ["dynamic-programming", "knapsack", "optimization"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-36",
    question: "Longest Common Subsequence (LCS)",
    category: "dynamic-programming",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use 2D DP table where dp[i][j] represents LCS length of first i characters of string1 and first j characters of string2. If characters match, dp[i][j] = 1 + dp[i-1][j-1]. If not, dp[i][j] = max(dp[i-1][j], dp[i][j-1]). Can optimize space to O(min(m,n)). Time complexity: O(m*n), Space complexity: O(m*n) or O(min(m,n)) optimized.",
    tips: [
      "Explain the recurrence relation",
      "Discuss how to reconstruct the actual LCS",
      "Compare with Longest Common Substring"
    ],
    tags: ["dynamic-programming", "strings", "lcs"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-37",
    question: "Coin change problem (minimum coins)",
    category: "dynamic-programming",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use DP where dp[amount] represents minimum coins needed for that amount. For each amount, try all coin denominations and take minimum. Base case: dp[0] = 0. Recurrence: dp[i] = min(dp[i], dp[i-coin] + 1) for all valid coins. Use infinity as initial value to handle impossible cases. Time complexity: O(amount * coins), Space complexity: O(amount).",
    tips: [
      "Handle impossible cases with infinity",
      "Explain why greedy doesn't always work",
      "Discuss the bottom-up approach"
    ],
    tags: ["dynamic-programming", "coins", "optimization"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-38",
    question: "Longest Increasing Subsequence (LIS)",
    category: "dynamic-programming",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Two approaches: 1) DP: dp[i] represents LIS length ending at index i. For each element, check all previous smaller elements. O(n²) time. 2) Binary search optimization: maintain array of smallest tail elements for each length, use binary search to find position. O(n log n) time. Second approach is preferred for large inputs.",
    tips: [
      "Explain the DP state definition",
      "Discuss binary search optimization",
      "Compare time complexities of both approaches"
    ],
    tags: ["dynamic-programming", "subsequence", "binary-search"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-39",
    question: "Edit distance between two strings (Levenshtein distance)",
    category: "dynamic-programming",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use 2D DP where dp[i][j] represents edit distance between first i characters of string1 and first j characters of string2. Three operations: insert, delete, replace. If characters match, dp[i][j] = dp[i-1][j-1]. Otherwise, dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]). Time complexity: O(m*n), Space complexity: O(m*n) or O(min(m,n)) optimized.",
    tips: [
      "Explain the three edit operations",
      "Discuss space optimization",
      "Mention applications like spell checkers"
    ],
    tags: ["dynamic-programming", "strings", "edit-distance"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Sorting and Searching Questions
  {
    id: "dsa-40",
    question: "Implement QuickSort and explain its time complexity",
    category: "sorting",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "QuickSort uses divide-and-conquer: choose a pivot, partition array so elements < pivot are left, elements > pivot are right, recursively sort both parts. Partition is key: use two pointers to swap elements. Average time complexity: O(n log n), worst case: O(n²) when pivot is always smallest/largest. Space complexity: O(log n) average for recursion stack.",
    tips: [
      "Explain partitioning process clearly",
      "Discuss pivot selection strategies",
      "Compare with other sorting algorithms"
    ],
    tags: ["sorting", "quicksort", "divide-conquer"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-41",
    question: "Implement MergeSort and analyze its stability",
    category: "sorting",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "MergeSort uses divide-and-conquer: divide array into halves, recursively sort both halves, merge sorted halves. Merge process compares elements from both halves and builds sorted result. Always O(n log n) time complexity regardless of input. Space complexity: O(n) for temporary arrays. It's stable (maintains relative order of equal elements).",
    tips: [
      "Explain the merge process step by step",
      "Discuss stability property",
      "Compare with QuickSort trade-offs"
    ],
    tags: ["sorting", "mergesort", "stability"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-42",
    question: "Binary search in a sorted array",
    category: "searching",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Divide and conquer approach: compare target with middle element. If equal, found. If target is smaller, search left half. If larger, search right half. Continue until found or search space is empty. Key is updating left/right pointers correctly to avoid infinite loops. Time complexity: O(log n), Space complexity: O(1) iterative, O(log n) recursive.",
    tips: [
      "Handle integer overflow in mid calculation",
      "Discuss termination conditions",
      "Explain why array must be sorted"
    ],
    tags: ["searching", "binary-search", "divide-conquer"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-43",
    question: "Find peak element in an array",
    category: "searching",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "A peak element is greater than its neighbors. Use binary search: check middle element, if it's greater than right neighbor, peak exists in left half (including middle), otherwise peak exists in right half. This works because there's always at least one peak. Time complexity: O(log n), Space complexity: O(1).",
    tips: [
      "Explain why binary search works here",
      "Handle edge cases at boundaries",
      "Discuss multiple peaks scenario"
    ],
    tags: ["searching", "binary-search", "peak"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-44",
    question: "Search in rotated sorted array",
    category: "searching",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Modified binary search: first determine which half is sorted by comparing with boundaries. If target is in the sorted half and within its range, search that half; otherwise search the other half. Key insight is that at least one half is always sorted in rotated array. Time complexity: O(log n), Space complexity: O(1).",
    tips: [
      "Identify which half is properly sorted",
      "Handle duplicates case separately",
      "Explain the rotation point concept"
    ],
    tags: ["searching", "binary-search", "rotation"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Heap Questions
  {
    id: "dsa-45",
    question: "Find kth largest element in an array",
    category: "heaps",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Multiple approaches: 1) Sort array and return element at index n-k: O(n log n). 2) Use min-heap of size k: maintain heap with k largest elements seen so far, root is kth largest: O(n log k). 3) QuickSelect algorithm: partition around random pivot like QuickSort but only recurse on relevant half: O(n) average, O(n²) worst case.",
    tips: [
      "Compare different approaches and their trade-offs",
      "Explain when to use each method",
      "Discuss QuickSelect's average case analysis"
    ],
    tags: ["heaps", "selection", "quickselect"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-46",
    question: "Merge k sorted linked lists",
    category: "heaps",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Use a min-heap to store the head of each list. Extract minimum, add its next node to heap (if exists), and build result list. This ensures we always pick the globally smallest element. Time complexity: O(n log k) where n is total nodes and k is number of lists. Space complexity: O(k) for heap.",
    tips: [
      "Explain why heap is efficient here",
      "Compare with divide-and-conquer approach",
      "Handle empty lists properly"
    ],
    tags: ["heaps", "linked-lists", "merge"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-47",
    question: "Find median from data stream",
    category: "heaps",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Use two heaps: max-heap for smaller half, min-heap for larger half. Keep heaps balanced (size difference ≤ 1). For even total elements, median is average of both tops. For odd, median is top of larger heap. When adding number, add to appropriate heap and rebalance if needed. Time complexity: O(log n) for insertion, O(1) for median.",
    tips: [
      "Explain the two-heap strategy",
      "Discuss balancing conditions",
      "Handle the rebalancing process"
    ],
    tags: ["heaps", "median", "data-stream"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Hash Table Questions
  {
    id: "dsa-48",
    question: "Design and implement a hash table",
    category: "hashing",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Key components: 1) Hash function: converts keys to array indices, should distribute uniformly. 2) Collision resolution: chaining (linked lists at each bucket) or open addressing (linear/quadratic probing). 3) Dynamic resizing: when load factor exceeds threshold, create larger table and rehash all elements. Good hash function and proper load factor management are crucial for O(1) average performance.",
    tips: [
      "Explain different collision resolution strategies",
      "Discuss load factor and resizing",
      "Compare chaining vs open addressing"
    ],
    tags: ["hashing", "design", "collision-resolution"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-49",
    question: "Find first non-repeating character in a string",
    category: "hashing",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Two approaches: 1) Use hash map to count character frequencies, then iterate through string to find first character with count 1. 2) Use hash map to store first occurrence index, mark duplicates with -1, find minimum valid index. Time complexity: O(n), Space complexity: O(1) since charset is limited.",
    tips: [
      "Consider character set size",
      "Handle case where no unique character exists",
      "Discuss single-pass vs two-pass approaches"
    ],
    tags: ["hashing", "strings", "frequency"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-50",
    question: "Group anagrams using hashing",
    category: "hashing",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use hash map where key represents anagram signature and value is list of anagrams. Two signature approaches: 1) Sort characters of each string as key. 2) Use character frequency array as key. Sorting approach is simpler, frequency approach avoids sorting cost. Time complexity: O(n * k log k) for sorting approach where k is average string length.",
    tips: [
      "Compare different key generation strategies",
      "Handle empty strings",
      "Discuss hash collision possibilities"
    ],
    tags: ["hashing", "strings", "anagrams"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Backtracking Questions
  {
    id: "dsa-51",
    question: "Generate all permutations of an array",
    category: "backtracking",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use backtracking: for each position, try all unused elements, recursively generate permutations for remaining positions, then backtrack by removing the element. Use a boolean visited array or swap elements in-place. Time complexity: O(n! * n), Space complexity: O(n) for recursion stack.",
    tips: [
      "Explain backtracking template",
      "Handle duplicate elements case",
      "Compare recursive vs iterative approaches"
    ],
    tags: ["backtracking", "permutations", "recursion"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-52",
    question: "Solve N-Queens problem",
    category: "backtracking",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Place queens row by row using backtracking. For each row, try placing queen in each column, check if position is safe (no conflicts with previous queens in same column, diagonal, or anti-diagonal), recursively solve for next row, backtrack if no solution found. Use arrays to track occupied columns and diagonals for O(1) conflict checking.",
    tips: [
      "Explain conflict checking optimization",
      "Discuss diagonal representation using formulas",
      "Compare different state representations"
    ],
    tags: ["backtracking", "n-queens", "constraint-satisfaction"],
    estimatedTime: 6,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-53",
    question: "Generate all valid parentheses combinations",
    category: "backtracking",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use backtracking with constraints: track count of open and close parentheses used. Add open parenthesis if count < n, add close parenthesis if close count < open count. This ensures validity. Backtrack by removing last character. Time complexity: O(4^n / √n) (Catalan number), Space complexity: O(n) for recursion.",
    tips: [
      "Explain the validity constraints",
      "Discuss Catalan number connection",
      "Show how constraints prune invalid paths"
    ],
    tags: ["backtracking", "parentheses", "constraints"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Two Pointers Questions
  {
    id: "dsa-54",
    question: "Three Sum problem (find triplets that sum to zero)",
    category: "two-pointers",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Sort the array first. For each element as first element of triplet, use two pointers on remaining array to find pairs that sum to negative of first element. Skip duplicates to avoid duplicate triplets. Time complexity: O(n²), Space complexity: O(1) not counting output.",
    tips: [
      "Explain duplicate handling strategy",
      "Discuss why sorting is necessary",
      "Compare with hash map approach"
    ],
    tags: ["two-pointers", "arrays", "triplets"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-55",
    question: "Container with most water",
    category: "two-pointers",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use two pointers at start and end of array. Calculate area with current pointers, update maximum. Move the pointer with smaller height inward (moving larger height pointer can't improve area). Continue until pointers meet. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Explain why we move the smaller height pointer",
      "Prove that this doesn't miss the optimal solution",
      "Visualize the problem geometrically"
    ],
    tags: ["two-pointers", "arrays", "optimization"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-56",
    question: "Remove duplicates from sorted array",
    category: "two-pointers",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use two pointers: slow (write position) and fast (read position). When fast finds new unique element, copy to slow position and increment slow. This maintains relative order and works in-place. Return slow as new length. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Explain in-place modification",
      "Handle edge cases like empty array",
      "Generalize to allow k duplicates"
    ],
    tags: ["two-pointers", "arrays", "duplicates"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Sliding Window Questions
  {
    id: "dsa-57",
    question: "Longest substring with at most k distinct characters",
    category: "sliding-window",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use sliding window with hash map to track character frequencies. Expand window by moving right pointer and adding characters. When distinct characters exceed k, shrink window from left until we have ≤ k distinct characters. Track maximum window size throughout. Time complexity: O(n), Space complexity: O(k).",
    tips: [
      "Explain sliding window expansion and contraction",
      "Handle k = 0 edge case",
      "Discuss character frequency tracking"
    ],
    tags: ["sliding-window", "strings", "hash-map"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-58",
    question: "Minimum window substring containing all characters of pattern",
    category: "sliding-window",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Use sliding window with two hash maps: one for pattern character frequencies, one for current window. Expand window until all pattern characters are covered, then try to shrink from left while maintaining coverage. Track minimum window size and position. Time complexity: O(n + m), Space complexity: O(m) where m is pattern length.",
    tips: [
      "Explain how to check if window is valid",
      "Optimize the shrinking process",
      "Handle edge cases like pattern longer than string"
    ],
    tags: ["sliding-window", "strings", "minimum"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-59",
    question: "Maximum sum subarray of size k",
    category: "sliding-window",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use fixed-size sliding window: calculate sum of first k elements, then slide window by removing leftmost element and adding new rightmost element. Track maximum sum seen. This avoids recalculating entire window sum each time. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Explain the sliding technique",
      "Compare with brute force approach",
      "Handle edge cases like k > array length"
    ],
    tags: ["sliding-window", "arrays", "subarray"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Greedy Algorithm Questions
  {
    id: "dsa-60",
    question: "Activity selection problem (meeting rooms)",
    category: "greedy",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Sort activities by end time. Greedily select activities: pick first activity, then select next activity whose start time ≥ current activity's end time. This greedy choice is optimal because picking activity with earliest end time leaves most room for future activities. Time complexity: O(n log n) for sorting.",
    tips: [
      "Explain why sorting by end time is optimal",
      "Prove the greedy choice property",
      "Compare with other sorting criteria"
    ],
    tags: ["greedy", "intervals", "scheduling"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-61",
    question: "Fractional knapsack problem",
    category: "greedy",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Calculate value-to-weight ratio for each item, sort by this ratio in descending order. Greedily pick items with highest ratio first. If an item doesn't fit completely, take fractional part. This greedy approach is optimal for fractional knapsack. Time complexity: O(n log n), Space complexity: O(1).",
    tips: [
      "Explain why ratio-based greedy works",
      "Compare with 0/1 knapsack",
      "Handle fractional parts correctly"
    ],
    tags: ["greedy", "knapsack", "optimization"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-62",
    question: "Minimum number of coins to make change",
    category: "greedy",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "For standard coin systems (like US coins), greedy works: always pick largest coin ≤ remaining amount. However, greedy doesn't work for arbitrary coin systems - need DP for general case. For greedy to work, coin system must have greedy choice property. Time complexity: O(amount/smallest_coin) for greedy.",
    tips: [
      "Explain when greedy works vs when it doesn't",
      "Give examples of non-greedy coin systems",
      "Compare with DP approach"
    ],
    tags: ["greedy", "coins", "optimization"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Trie Questions
  {
    id: "dsa-63",
    question: "Implement a Trie (Prefix Tree)",
    category: "tries",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Trie node contains children array (26 for lowercase letters) and boolean for end-of-word. Insert: traverse path creating nodes as needed, mark last node as end-of-word. Search: traverse path, return true if path exists and ends at end-of-word node. StartsWith: similar to search but don't check end-of-word. Time complexity: O(m) for all operations where m is word length.",
    tips: [
      "Explain the tree structure clearly",
      "Discuss space optimization techniques",
      "Compare with hash table for prefix operations"
    ],
    tags: ["tries", "strings", "prefix"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-64",
    question: "Word search in a 2D grid using Trie",
    category: "tries",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Build trie from word list, then DFS from each cell in grid. During DFS, follow trie paths and mark words when reaching end-of-word nodes. Use backtracking to explore all paths and avoid revisiting cells in current path. This is more efficient than searching each word separately. Time complexity: O(m*n*4^k) where k is maximum word length.",
    tips: [
      "Explain the DFS + Trie combination",
      "Discuss backtracking for path exploration",
      "Optimize by pruning invalid trie paths"
    ],
    tags: ["tries", "dfs", "backtracking"],
    estimatedTime: 6,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Bit Manipulation Questions
  {
    id: "dsa-65",
    question: "Find single number in array where every other number appears twice",
    category: "bit-manipulation",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Use XOR operation: XOR all numbers in the array. Since a XOR a = 0 and a XOR 0 = a, all pairs will cancel out leaving only the single number. This works because XOR is commutative and associative. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Explain XOR properties",
      "Generalize to other occurrence patterns",
      "Discuss bit manipulation advantages"
    ],
    tags: ["bit-manipulation", "xor", "single-number"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-66",
    question: "Count number of 1 bits in an integer",
    category: "bit-manipulation",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Several approaches: 1) Check each bit using n & 1, then right shift. 2) Use n & (n-1) which clears rightmost set bit, count iterations until n becomes 0. 3) Use built-in popcount function. The n & (n-1) approach is most elegant and efficient for sparse bit patterns.",
    tips: [
      "Explain the n & (n-1) trick",
      "Compare different bit manipulation techniques",
      "Handle negative numbers (two's complement)"
    ],
    tags: ["bit-manipulation", "counting", "optimization"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-67",
    question: "Find two non-repeating numbers in array where every other number appears twice",
    category: "bit-manipulation",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "XOR all numbers to get XOR of the two unique numbers. Find any set bit in this XOR result (rightmost set bit is easiest). Divide numbers into two groups based on this bit position, XOR each group separately. Each group will have one unique number since pairs are separated. Time complexity: O(n), Space complexity: O(1).",
    tips: [
      "Explain the grouping strategy",
      "Show how pairs get separated",
      "Discuss bit position selection"
    ],
    tags: ["bit-manipulation", "xor", "grouping"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Math Questions
  {
    id: "dsa-68",
    question: "Check if a number is prime",
    category: "math",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Check divisibility from 2 to √n. If any number divides n, it's not prime. Optimizations: check 2 separately, then only odd numbers from 3 to √n. For multiple queries, use Sieve of Eratosthenes to precompute all primes up to limit. Time complexity: O(√n) for single check, O(n log log n) for sieve.",
    tips: [
      "Explain why checking up to √n is sufficient",
      "Discuss optimizations for multiple queries",
      "Handle edge cases like 1, 2, negative numbers"
    ],
    tags: ["math", "prime", "optimization"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-69",
    question: "Calculate power of a number efficiently (exponentiation by squaring)",
    category: "math",
    difficulty: "medium",
    type: "technical",
    sampleAnswer: "Use binary exponentiation: if exponent is even, result = power(base², exp/2); if odd, result = base * power(base², (exp-1)/2). This reduces O(n) naive approach to O(log n). Handle negative exponents by taking reciprocal and making exponent positive.",
    tips: [
      "Explain the divide-and-conquer approach",
      "Handle negative exponents and base",
      "Discuss iterative vs recursive implementation"
    ],
    tags: ["math", "exponentiation", "divide-conquer"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-70",
    question: "Find GCD of two numbers using Euclidean algorithm",
    category: "math",
    difficulty: "easy",
    type: "technical",
    sampleAnswer: "Euclidean algorithm: GCD(a,b) = GCD(b, a%b) until one number becomes 0. The other number is the GCD. This works because GCD(a,b) = GCD(b, a-b) and a%b is efficient way to compute a-kb for largest k. Time complexity: O(log(min(a,b))), Space complexity: O(1) iterative.",
    tips: [
      "Explain why the algorithm works",
      "Compare recursive vs iterative versions",
      "Discuss applications like simplifying fractions"
    ],
    tags: ["math", "gcd", "euclidean"],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },

  // Advanced Questions
  {
    id: "dsa-71",
    question: "Design LRU Cache",
    category: "design",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Use hash map + doubly linked list. Hash map provides O(1) access to nodes, doubly linked list maintains order (most recent at head, least recent at tail). For get: move accessed node to head. For put: if key exists, update and move to head; if new key and at capacity, remove tail node and its hash entry, add new node at head.",
    tips: [
      "Explain why doubly linked list is needed",
      "Show the data structure combination",
      "Handle edge cases like capacity 1"
    ],
    tags: ["design", "lru", "hash-map", "linked-list"],
    estimatedTime: 6,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-72",
    question: "Serialize and deserialize a binary tree",
    category: "trees",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Use preorder traversal for serialization: convert tree to string with null markers. For deserialization: build tree using preorder sequence, use index/iterator to track position. Can use any traversal but preorder is most intuitive. Handle null nodes explicitly in serialization. Time complexity: O(n) for both operations.",
    tips: [
      "Explain choice of traversal method",
      "Handle null node representation",
      "Discuss delimiter and parsing issues"
    ],
    tags: ["trees", "serialization", "preorder"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-73",
    question: "Find median of two sorted arrays",
    category: "binary-search",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Use binary search on the smaller array to find partition point. Partition both arrays such that left halves have equal total length and all elements in left ≤ all elements in right. Check if partition is valid by comparing boundary elements. Adjust partition based on comparison. Time complexity: O(log(min(m,n))).",
    tips: [
      "Explain the partitioning concept",
      "Handle even vs odd total length",
      "Discuss why we binary search on smaller array"
    ],
    tags: ["binary-search", "arrays", "median"],
    estimatedTime: 6,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-74",
    question: "Trapping rain water",
    category: "arrays",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Multiple approaches: 1) For each position, water level = min(max_left, max_right) - current_height. 2) Two pointers: move pointer with smaller max inward, water trapped is determined by smaller max. 3) Stack-based: store indices of bars, calculate water when finding taller bar. Two pointers approach is most elegant with O(1) space.",
    tips: [
      "Visualize the water trapping concept",
      "Explain the two-pointer logic",
      "Compare space-time tradeoffs of different approaches"
    ],
    tags: ["arrays", "two-pointers", "water-trapping"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "dsa-75",
    question: "Design a data structure for range sum queries (Segment Tree)",
    category: "advanced",
    difficulty: "hard",
    type: "technical",
    sampleAnswer: "Segment tree is a binary tree where each node represents a range. Leaf nodes represent single elements, internal nodes represent union of children ranges and store aggregate (sum/min/max). Build: recursively divide range and compute aggregates. Query: if query range matches node range, return stored value; otherwise combine results from relevant children. Update: modify leaf and propagate changes up. Time complexity: O(log n) for query/update, O(n) for build.",
    tips: [
      "Explain the tree structure and range representation",
      "Discuss lazy propagation for range updates",
      "Compare with other range query data structures"
    ],
    tags: ["advanced", "segment-tree", "range-queries"],
    estimatedTime: 6,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
];