import { Question } from "../InterviewSubjects";

// Collection of React interview questions
export const reactQuestions: Question[] = [
  {
    id: "react-1",
    question: "Explain the difference between state and props in React.",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Props (short for properties) and state are both JavaScript objects that hold information, but they serve different purposes. Props are passed to a component from its parent and are read-only within the component, making them immutable. They enable parent-to-child component communication. State, on the other hand, is managed within the component itself and can change over time, usually in response to user events or network responses. State is mutable and allows components to create and manage their own data. When state changes, React re-renders the component. While props flow downward from parent to child, state is confined to the component where it's declared, unless explicitly shared with children through their props.",
    tips: [
      "Mention the unidirectional flow of props",
      "Discuss when to use state vs. props",
      "Explain state lifting for sharing state",
      "Reference the useState hook for functional components",
    ],
    tags: ["react", "frontend", "javascript", "react-core-concepts"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-2",
    question:
      "What are React hooks? Explain some common hooks and their use cases.",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React hooks are functions that let you use state and other React features in functional components, introduced in React 16.8. They allow you to reuse stateful logic without changing your component hierarchy. Some common hooks include: useState for managing state within functional components; useEffect for handling side effects like data fetching, subscriptions, or DOM manipulations (replacing lifecycle methods); useContext for consuming context in components without nesting; useRef for maintaining mutable references that persist across renders; useReducer for managing complex state logic; useMemo and useCallback for performance optimizations by memoizing values and functions between renders. Custom hooks can also be created to extract and reuse component logic, improving code reusability and separation of concerns. Hooks must follow rules: only call them at the top level (not inside conditions, loops, or nested functions) and only call them from React functions, not regular JavaScript functions.",
    tips: [
      "Compare hooks with class components",
      "Discuss the rules of hooks",
      "Explain how custom hooks enable code reuse",
      "Demonstrate a simple useState example",
    ],
    tags: ["react", "frontend", "javascript", "hooks", "react-core-concepts"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-3",
    question:
      "Explain React's component lifecycle methods and their hooks equivalents.",
    category: "technical",
    difficulty: "hard",
    type: "technical",
    sampleAnswer:
      "In class components, React's lifecycle methods are divided into mounting (constructor, static getDerivedStateFromProps, render, componentDidMount), updating (getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate), and unmounting (componentWillUnmount) phases. With hooks, these are replaced by: useState replaces constructor for state initialization; useEffect with empty dependency array replaces componentDidMount; useEffect with dependencies replaces componentDidUpdate; useEffect with cleanup function replaces componentWillUnmount; useMemo can replace shouldComponentUpdate for performance optimization. The useEffect hook combines componentDidMount, componentDidUpdate, and componentWillUnmount, creating a more unified API. Error boundaries (componentDidCatch and getDerivedStateFromError) still require class components as they don't have hook equivalents yet. The newer approach with hooks provides better composition, avoids the this binding confusion, encourages separating logic by concern rather than lifecycle method, and generally leads to more maintainable code.",
    tips: [
      "Compare mounting and unmounting in classes vs. hooks",
      "Discuss common pitfalls in lifecycle methods",
      "Explain how dependency arrays control effect execution",
      "Mention that error boundaries still require class components",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "lifecycle",
      "hooks",
      "react-advanced",
    ],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-4",
    question: "What is Redux and when would you use it?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Redux is a predictable state management library for JavaScript applications, commonly used with React. It centralizes application state in a single 'store' and uses a strict unidirectional data flow to update that state. The core principles include: having a single source of truth (the store); state is read-only and only changed by dispatching actions; changes are made with pure functions called reducers. Redux is useful when: your application has complex state logic affecting multiple components; state needs to be accessed by many components across different parts of the app; your state update logic is complex; you need to track every state change for debugging or undo/redo functionality. While Redux adds complexity and boilerplate, it provides benefits like predictable state updates, centralized logic, improved debugging with tools like Redux DevTools, and time-travel debugging. With React's Context API and useReducer hook, simpler applications may not need Redux, but it remains valuable for larger, more complex applications that need robust state management.",
    tips: [
      "Explain the Redux flow (action → reducer → store → view)",
      "Discuss Redux middleware like thunk or saga",
      "Compare with React's built-in state management",
      "Mention modern alternatives like Recoil or Zustand",
    ],
    tags: ["react", "frontend", "javascript", "redux", "state-management"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-5",
    question: "What are the key performance optimization techniques in React?",
    category: "technical",
    difficulty: "hard",
    type: "technical",
    sampleAnswer:
      "React performance optimization focuses on minimizing unnecessary renders and improving render efficiency. Key techniques include: React.memo for functional components and PureComponent for class components to skip re-renders when props haven't changed; useMemo to memoize computed values across renders; useCallback to prevent function recreations that cause child components to re-render; Code splitting with React.lazy and Suspense to reduce initial bundle size; Virtualization for long lists using libraries like react-window or react-virtualized; Proper key usage in lists for efficient reconciliation; Avoiding inline function definitions and object literals in render to prevent unnecessary re-renders; Throttling and debouncing event handlers for performance-intensive operations; Using the production build which includes optimizations; Implementing progressive loading and rendering for complex UIs; Optimizing Context API usage by splitting contexts or memoizing context values; State colocation by keeping state as close as possible to where it's used. Tools like React DevTools Profiler and Chrome Performance tab can identify performance bottlenecks. Optimizations should be applied strategically where needed, not prematurely.",
    tips: [
      "Demonstrate how to use React DevTools to identify performance issues",
      "Discuss the importance of measuring before optimizing",
      "Explain the difference between memoization techniques",
      "Address SSR and hydration optimizations",
    ],
    tags: ["react", "frontend", "javascript", "performance", "optimization"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-6",
    question: "Explain React's Virtual DOM and how it improves performance.",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "The Virtual DOM is a lightweight JavaScript representation of the actual DOM in memory. When state changes in a React application, instead of directly manipulating the browser's DOM (which is slow), React creates a new Virtual DOM tree and compares it with the previous one through a process called 'reconciliation' or 'diffing'. React then updates only the parts of the real DOM that actually changed, minimizing expensive DOM operations. This approach offers performance benefits because: DOM manipulation is the most expensive part of web applications; batch updates reduce browser reflows and repaints; unnecessary updates are avoided through shouldComponentUpdate, React.memo, and PureComponent; cross-browser compatibility issues are handled by React. The process flows as: state changes, React builds a new Virtual DOM tree, differs it with the previous version, computes the minimal set of changes needed, and applies only those changes to the real DOM. This declarative approach simplifies development while maintaining performance. However, it's important to note that Virtual DOM isn't always faster than direct DOM manipulation for simple updates, but it provides the optimal balance between developer experience and performance for complex applications.",
    tips: [
      "Contrast with direct DOM manipulation approaches",
      "Explain the reconciliation algorithm basics",
      "Discuss key-based reconciliation for lists",
      "Address common misconceptions about Virtual DOM",
    ],
    tags: ["react", "frontend", "javascript", "virtual-dom", "performance"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-7",
    question: "What are controlled and uncontrolled components in React?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "In React, form elements like input, textarea, and select traditionally maintain their own state in the DOM. Controlled components are those where form data is handled by the React component's state. The component renders the form element with values from its state and includes event handlers to update that state when the user interacts with the form. This creates a single source of truth for the form data, making it easier to validate, transform, or submit the data. For example, an input element's value is set through the value prop and updated via an onChange handler that calls setState. Uncontrolled components, on the other hand, store form state in the DOM itself, more like traditional HTML forms. React provides refs to access the DOM element's values when needed, such as during form submission. While uncontrolled components require less code and can integrate more easily with non-React code, controlled components offer more robust form handling with immediate access to input values, dynamic validation, conditional disabling of form elements, and enforcing specific input formats. The general recommendation is to use controlled components in most cases for their predictability and control, though uncontrolled components have legitimate use cases for simple forms or when integrating with legacy code.",
    tips: [
      "Demonstrate simple code examples of both approaches",
      "Explain when to use each approach",
      "Discuss form libraries like Formik or React Hook Form",
      "Address handling multiple inputs efficiently",
    ],
    tags: ["react", "frontend", "javascript", "forms", "react-core-concepts"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-8",
    question: "What is React Context API and when would you use it?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React Context API provides a way to share data between components without passing props manually through each level of the component tree, solving the 'prop drilling' problem. It consists of three main parts: React.createContext creates a Context object; Context.Provider wraps components and supplies the value; Context.Consumer or useContext hook allows components to consume that value. Context is ideal for global data needed by many components at different nesting levels, such as authenticated user information, theme settings, language preferences, or application configuration. While powerful, Context should be used judiciously as it can make component reuse more difficult and impact performance in large applications since all consumers re-render when the context value changes. For complex state management needs, Context is often combined with useReducer hook to create a lightweight Redux-like solution. Context doesn't replace Redux for applications with complex state interactions, middleware requirements, or extensive developer tooling needs. Best practices include keeping context focused on specific concerns, optimizing with memoization when appropriate, and splitting multiple contexts rather than having one large context object.",
    tips: [
      "Compare with other state management approaches",
      "Demonstrate the useContext hook usage",
      "Explain context value optimization with useMemo",
      "Discuss performance considerations for large-scale applications",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "context-api",
      "state-management",
    ],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-9",
    question: "What are React portals and when would you use them?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React portals provide a way to render children into a DOM node outside the parent component's DOM hierarchy while maintaining the React context and event bubbling. Created using ReactDOM.createPortal(child, container), portals are particularly useful for components that need to visually 'break out' of their container, such as modals, tooltips, floating menus, and notifications. Without portals, these components might suffer from CSS overflow, z-index, or positioning constraints when they remain in their natural position in the React component tree. Despite rendering outside the DOM hierarchy, portal components maintain normal React behavior: events still bubble up through the React component tree (not the DOM tree), context works as expected, and React can still manage their lifecycle. This makes portals more powerful than simply appending elements to the DOM. Common use cases include: modals that should appear above everything else; tooltips that need to escape clipped containers; widgets that insert into specific DOM locations while being controlled by a React component elsewhere. Portals solve these UI challenges elegantly while maintaining React's component model and synthetic event system.",
    tips: [
      "Provide a simple modal example using portals",
      "Explain event bubbling through portals",
      "Compare with older approaches for similar functionality",
      "Discuss accessibility considerations when using portals",
    ],
    tags: ["react", "frontend", "javascript", "portals", "react-advanced"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-10",
    question: "What are React refs and when should you use them?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React refs provide a way to access and interact with DOM nodes or React elements directly. Created using React.createRef() in class components or the useRef hook in functional components, refs are essentially objects with a .current property that points to the DOM node or React component instance. Refs should be used sparingly for cases that can't be handled through the normal React data flow, such as: managing focus, text selection, or media playback; triggering imperative animations; integrating with third-party DOM libraries; and measuring DOM node dimensions or position. Unlike props, modifying a ref doesn't cause re-renders, making them suitable for storing mutable values that don't affect the UI directly. In functional components, useRef can also be used to persist values across renders without causing re-renders, essentially acting as an instance variable. Best practices include avoiding refs for anything that can be done declaratively, limiting direct DOM manipulations, and using callback refs when ref creation and attachment need to be synchronized. Overusing refs can make code harder to understand and maintain, as it often circumvents React's declarative programming model.",
    tips: [
      "Compare useRef with useState for storing values",
      "Demonstrate focus management with refs",
      "Explain forwardRef for passing refs to custom components",
      "Discuss callback refs and their use cases",
    ],
    tags: ["react", "frontend", "javascript", "refs", "dom-manipulation"],
    estimatedTime: 3,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-11",
    question: "Explain React's error boundaries and how to implement them.",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Error boundaries in React are special components that catch JavaScript errors in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application. They catch errors during rendering, in lifecycle methods, and in constructors, but don't catch errors in event handlers, asynchronous code, or errors thrown in the error boundary itself. To implement an error boundary, create a class component that defines either the static getDerivedStateFromError() method (to render fallback UI) or componentDidCatch() method (for logging), or both. For example, a simple error boundary might set an 'hasError' state when an error occurs and render an alternative UI. Error boundaries work like try-catch blocks for React components and can be placed anywhere in the component tree to protect different parts of the application. Best practices include placing error boundaries strategically to balance resilience with appropriate error isolation, displaying user-friendly error messages, logging errors to monitoring services, and potentially providing recovery options. Currently, there's no hook equivalent for error boundaries, so class components are still required for this functionality, though you can create a functional wrapper around a class-based error boundary.",
    tips: [
      "Provide a complete error boundary component example",
      "Explain where to place error boundaries strategically",
      "Discuss error reporting and monitoring integration",
      "Mention limitations of error boundaries",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "error-handling",
      "react-advanced",
    ],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-12",
    question:
      "What is React Server Components and how does it differ from traditional React?",
    category: "technical",
    difficulty: "hard",
    type: "technical",
    sampleAnswer:
      "React Server Components (RSC) is a new architecture that allows components to render on the server while maintaining many of React's core benefits. Unlike traditional React where all components run in the browser, RSC splits components into server components and client components. Server components run only on the server, can access server resources directly (databases, filesystems), never ship to the client, and don't require client-side JavaScript. They're ideal for data fetching and generating static content. Client components (marked with 'use client' directive) run on both server for initial render and client for interactivity, containing event handlers and hooks for state. The key benefits include: reduced bundle size as server component code never ships to clients; direct backend access without API layers; automatic code splitting; improved loading performance; and still maintaining React's component model and compositional nature. Unlike traditional server-side rendering (SSR) which sends HTML then hydrates with JavaScript, server components send a special format that can be integrated into the client React tree without full hydration. This approach combines the best of server rendering (faster loading, better SEO) with client-side interactivity, while reducing JavaScript payload. RSC is still evolving but represents a significant architectural shift in how React applications are built and delivered.",
    tips: [
      "Compare with traditional SSR and client-side rendering",
      "Explain the 'use client' and 'use server' directives",
      "Discuss streaming and progressive hydration benefits",
      "Address current limitations and adoption considerations",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "server-components",
      "react-advanced",
    ],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-13",
    question:
      "How does React handle routing and what are the main routing libraries?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React doesn't include built-in routing capabilities, so developers typically use routing libraries, with React Router being the most popular. React Router provides declarative routing with components like BrowserRouter, Routes, Route, Link, and Navigate. It supports dynamic route parameters, nested routes, and route-specific layouts. The latest versions (v6+) emphasize simplicity and hooks-based APIs with useParams, useNavigate, and useLocation. Other routing solutions include Reach Router (now merged into React Router), Next.js built-in routing for file-system based routes, and TanStack Router for type-safe routing with automatic route prefetching. Client-side routing intercepts navigation events, updates the URL, and renders the appropriate component without full page reloads. This provides faster transitions, preserved state, and a smoother user experience. Important routing concepts include: route configuration, route parameters, query parameters, nested routes, protected routes for authentication, navigation guards, and code-splitting routes. The choice of routing solution depends on application needs—React Router for traditional SPAs, Next.js routing for more comprehensive frameworks, or lightweight solutions for simpler applications. Modern routing often incorporates data loading patterns, error handling, and optimistic updates for improved user experiences.",
    tips: [
      "Compare different routing libraries and their approaches",
      "Demonstrate basic React Router setup and usage",
      "Explain handling authentication with routes",
      "Discuss code-splitting at the route level",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "routing",
      "single-page-applications",
    ],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-14",
    question: "What are React's Suspense and concurrent features?",
    category: "technical",
    difficulty: "hard",
    type: "technical",
    sampleAnswer:
      "React Suspense is a mechanism that allows components to 'wait' for something before rendering, showing a fallback UI during the waiting period. Originally introduced for code-splitting with React.lazy(), it has expanded to support data fetching and other asynchronous operations. Concurrent features build on this foundation, enabling React to work on multiple tasks simultaneously, interrupt and resume work based on priority, and adapt to varying user devices and network conditions. The core concepts include: Suspense boundaries that specify loading states; transitions that mark non-urgent updates which can be interrupted; automatic batching of state updates for performance; and selective hydration to prioritize interactive parts of the page. These features help solve common problems like keeping the UI responsive during expensive operations, avoiding display of inconsistent UI states, and improving perceived performance. Implementation uses Suspense components with fallback props for loading states, useDeferredValue for non-critical updates, useTransition for transitions between UI states, and startTransition for marking non-urgent updates. The concurrent rendering model is a significant shift from the previous synchronous model, making applications more responsive by allowing React to prioritize more urgent updates and work on multiple updates simultaneously without blocking the main thread.",
    tips: [
      "Demonstrate practical examples of Suspense for data fetching",
      "Explain the difference between useTransition and useDeferredValue",
      "Discuss how concurrent rendering improves user experience",
      "Address compatibility considerations with existing code",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "suspense",
      "concurrent-mode",
      "react-advanced",
    ],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-15",
    question: "What are custom hooks in React and how do you create them?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Custom hooks are JavaScript functions that start with 'use' and may call other hooks, enabling the extraction and reuse of stateful logic between components without changing the component hierarchy. They solve the problem of code duplication and complexity that higher-order components and render props patterns attempted to address. To create a custom hook, simply define a function whose name starts with 'use' (a convention that enables React's linting rules) and use existing React hooks inside it. For example, a useLocalStorage hook might combine useState and useEffect to persist state to localStorage. Custom hooks can accept parameters and return values, typically returning state variables and functions to update them. They follow the same rules as built-in hooks: only call hooks at the top level and only from React functions. Common use cases include form handling (useForm), API data fetching (useFetch), device media queries (useMediaQuery), animations (useAnimation), and authentication state (useAuth). The power of custom hooks lies in their composability—they can call other custom hooks, enabling complex logic to be broken down into smaller, reusable units. This approach keeps components focused on rendering while extracting complex stateful logic into well-named, reusable functions, significantly improving code organization and maintainability.",
    tips: [
      "Provide an example of a practical custom hook",
      "Explain how to test custom hooks effectively",
      "Discuss composing multiple hooks together",
      "Mention popular custom hook libraries and their benefits",
    ],
    tags: ["react", "frontend", "javascript", "hooks", "code-reuse"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-16",
    question:
      "What is the React component composition pattern and how does it differ from inheritance?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React favors composition over inheritance as a mechanism for reusing code between components. Component composition involves building larger components by combining smaller, focused components together, often using props.children to create wrapper components that add functionality or styling. Common composition patterns include: containment, where a component contains arbitrary children (like layouts or modals); specialization, where a more specific component renders a more generic one with custom props; and render props/children as functions, which pass rendering logic as props to share code. For example, a Dialog component might render different content through children, while a specialized ErrorDialog extends its functionality with specific props. Unlike inheritance which creates tight coupling through 'is-a' relationships, composition creates flexible 'has-a' relationships that are easier to modify and less prone to the fragile base class problem. Composition aligns with React's declarative and component-based nature, allowing for clearer interfaces between components, more testable code, and greater flexibility in changing implementation details. The React team explicitly recommends composition over inheritance, noting that all use cases traditionally solved with inheritance can be addressed through composition with cleaner separation of concerns.",
    tips: [
      "Provide examples of common composition patterns",
      "Contrast with inheritance approaches in OOP languages",
      "Discuss the special 'children' prop and how it enables composition",
      "Explain advanced techniques like render props and higher-order components",
    ],
    tags: ["react", "frontend", "javascript", "composition", "design-patterns"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-17",
    question: "How does React handle forms and form validation?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React handles forms through controlled components where form elements like inputs and selects are controlled by React state, or uncontrolled components where form data is handled by the DOM itself with refs for access. For form validation, there are several approaches: built-in HTML validation attributes (required, pattern, min/max); custom validation logic in event handlers that updates error state alongside form state; schema-based validation using libraries like Yup, Zod, or Joi combined with form libraries. Validation can be performed on different events: onChange (real-time feedback), onBlur (validate when a field loses focus), or onSubmit (validate all fields before submission). For complex forms, specialized libraries simplify management: Formik provides form state handling, validation, and submission; React Hook Form offers a performance-focused approach with uncontrolled components and reduced re-renders; Final Form emphasizes subscription-based updates for better performance; and Remix and React Router Forms integrate with their respective frameworks for progressive enhancement. These libraries typically support features like field arrays (dynamic field lists), conditional fields, wizard forms, and error summaries. Server-side validation remains essential for security, while client-side validation improves user experience by providing immediate feedback without round-trips to the server.",
    tips: [
      "Compare controlled vs. uncontrolled approaches for forms",
      "Demonstrate simple form validation with and without libraries",
      "Discuss accessibility considerations for form errors",
      "Address performance considerations for forms with many fields",
    ],
    tags: ["react", "frontend", "javascript", "forms", "validation"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-18",
    question: "What are React fragments and why are they useful?",
    category: "technical",
    difficulty: "easy",
    type: "technical",
    sampleAnswer:
      "React fragments are a feature that allows grouping multiple elements together without adding an extra node to the DOM. Since React components must return a single root element, developers previously had to wrap related elements in a container div or other HTML element, which could lead to invalid HTML in some cases (like within table structures) or unwanted styling/layout issues from the extra div. Fragments solve this by providing a wrapper that doesn't render any actual HTML element. They can be written using either the explicit syntax <React.Fragment>...</React.Fragment> or the shorthand syntax <>...</>. The explicit syntax is required when you need to provide a key prop for fragment items in a list. Fragments are particularly useful in several scenarios: returning multiple elements from a component; creating table rows and cells without invalid nesting; avoiding unnecessary DOM nodes that might break layouts or CSS grid/flexbox structures; rendering lists of items without wrapper elements; and keeping component return values cleaner. By not adding extra nodes to the DOM, fragments help maintain semantic HTML structure, improve rendering performance slightly, and prevent styling issues caused by unexpected container elements.",
    tips: [
      "Demonstrate both fragment syntaxes and when each is appropriate",
      "Show examples where fragments solve specific problems",
      "Explain fragment keys when mapping collections",
      "Compare with alternative approaches used before fragments existed",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "fragments",
      "react-core-concepts",
    ],
    estimatedTime: 2,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-19",
    question:
      "How does React handle SEO concerns, and what strategies can improve SEO in React applications?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "React applications face SEO challenges primarily because traditional single-page applications (SPAs) serve minimal HTML initially, with content populated by JavaScript after loading, which some search engine crawlers may not fully execute. Several strategies address this: Server-Side Rendering (SSR) generates complete HTML on the server for each request, providing crawlers with fully-rendered content; Static Site Generation (SSG) pre-renders pages at build time for optimal loading and crawling; and hybrid approaches like Incremental Static Regeneration combine pre-rendered pages with dynamic updates. React frameworks like Next.js and Remix provide built-in solutions for these rendering methods. Additional SEO optimization includes: using React Helmet or similar libraries to manage meta tags dynamically; implementing proper semantic HTML structure with appropriate heading hierarchy; ensuring accessibility which often correlates with better SEO; adding structured data (JSON-LD) for rich search results; optimizing images with proper dimensions, formats, and alt text; implementing proper URL structure and navigation; and ensuring fast page loading through code splitting, lazy loading, and performance optimization. Mobile friendliness is crucial, as Google primarily uses mobile-first indexing. For SPAs without server rendering, implementing dynamic OG meta tags through server-side generation or prerendering services helps with social media sharing.",
    tips: [
      "Compare different rendering approaches and their SEO impact",
      "Discuss how to test and monitor SEO performance in React apps",
      "Explain the role of sitemaps and robots.txt",
      "Address common SEO pitfalls specific to React applications",
    ],
    tags: ["react", "frontend", "javascript", "seo", "rendering-strategies"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-20",
    question: "What are React's key security concerns and best practices?",
    category: "technical",
    difficulty: "hard",
    type: "technical",
    sampleAnswer:
      "React applications face several security concerns that require specific mitigation strategies. For cross-site scripting (XSS), React's automatic escaping of variables in JSX provides good baseline protection, but risks remain when using dangerouslySetInnerHTML, generating dynamic URLs with user input, or evaluating code strings. Best practices include avoiding dangerouslySetInnerHTML when possible, using DOMPurify to sanitize HTML when necessary, and implementing Content Security Policy (CSP). For authentication and authorization, store tokens securely using HttpOnly cookies rather than localStorage to prevent client-side access, implement proper CSRF protection, and perform all authorization checks on the server. Third-party dependencies pose risks through supply chain attacks, so regularly audit packages with tools like npm audit, use lockfiles, consider runtime protection tools, and avoid excessive dependencies. Server-side rendering introduces unique concerns like preventing leakage of sensitive data during hydration and protecting against request forgery. Additional security measures include protecting against clickjacking with proper headers, implementing proper CORS policies, avoiding publishing sensitive information in client-side code, using environment variables for secrets, and enforcing HTTPS. Regular security audits, staying updated on React security practices, and following the principle of least privilege throughout the application architecture remain essential for maintaining a strong security posture.",
    tips: [
      "Explain specific XSS vectors in React applications",
      "Discuss state management security considerations",
      "Address server-side rendering security implications",
      "Provide examples of security headers and their benefits",
    ],
    tags: ["react", "frontend", "javascript", "security", "best-practices"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-21",
    question: "How do you implement code-splitting in React applications?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Code-splitting in React divides your application into smaller chunks that load on demand, reducing initial load time and improving performance. The primary method is dynamic imports using the import() syntax, which webpack recognizes and splits into separate bundles. React.lazy() builds on this by allowing components to be loaded only when needed, often combined with Suspense to show fallback content while loading. Common code-splitting strategies include: route-based splitting where each route loads its own code bundle; component-based splitting for large, complex components not needed immediately; feature-based splitting that loads features on demand; and library-based splitting to separate large dependencies. In React Router, you can implement code-splitting by wrapping components with React.lazy() and placing Suspense boundaries around route components. For more advanced needs, libraries like Loadable Components offer server-side rendering support and more granular control. To optimize the code-splitting strategy, use performance monitoring to identify large bundles, analyze loading patterns with tools like webpack-bundle-analyzer, preload critical chunks with <link rel='preload'> tags, and consider implementing intelligent prefetching based on user behavior. Effective code-splitting requires balancing bundle sizes—too many small chunks can increase HTTP request overhead, while too few large chunks defeat the purpose of splitting.",
    tips: [
      "Compare React.lazy with other code-splitting libraries",
      "Demonstrate route-based code-splitting implementation",
      "Explain webpack configuration for optimizing chunks",
      "Discuss strategies for prefetching and preloading chunks",
    ],
    tags: ["react", "frontend", "javascript", "performance", "code-splitting"],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-22",
    question:
      "What are higher-order components (HOCs) in React and when would you use them?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Higher-order components (HOCs) are functions that take a component and return a new enhanced component with additional props, state, or behavior. Following the pattern Component => EnhancedComponent, they implement the composition design pattern for reusing component logic. HOCs don't modify the input component but compose it by wrapping it in a container component. Common use cases include: adding state management or data fetching to stateless components; implementing access control by checking authentication before rendering; injecting props from external sources like Redux's connect() or React Router's withRouter; handling cross-cutting concerns like logging or analytics; and adding styling or layout variations to base components. For example, withLoading(Component) might add loading state and display a spinner while data loads. While powerful, HOCs have limitations: prop naming collisions can occur when multiple HOCs inject props with the same names; wrapper component nesting complicates debugging; and they lack straightforward type checking with TypeScript compared to newer patterns. Modern React applications often prefer hooks for stateful logic reuse and render props for rendering logic sharing, but HOCs remain valuable for certain use cases, especially library integrations. Best practices include: using composition utilities like recompose, maintaining a consistent naming convention for injected props, passing unrelated props through to the wrapped component, and maximizing composability with functional composition.",
    tips: [
      "Compare HOCs with hooks and render props approaches",
      "Demonstrate implementing a simple HOC with practical utility",
      "Explain how to avoid common HOC pitfalls",
      "Discuss where HOCs are still preferred over newer patterns",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "higher-order-components",
      "design-patterns",
    ],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-23",
    question: "How do you handle data fetching in React applications?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Data fetching in React has evolved from simple approaches to sophisticated patterns and libraries. The basic approach uses useEffect for fetching with useState for storing results, loading states, and errors. This pattern works well for simple cases but becomes unwieldy for complex scenarios. Custom hooks improve organization by extracting fetching logic into reusable functions like useFetch or useResource. Modern data fetching libraries provide more robust solutions: React Query and SWR offer automatic caching, background refetching, pagination support, and optimistic updates; Apollo Client specializes in GraphQL with a powerful caching system; RTK Query integrates with Redux for centralized state management; and Relay provides deep GraphQL integration with strong typing and colocation of components with their data needs. Server components in React 18+ enable direct server-side data fetching without client-side JavaScript. Common patterns include: request waterfalls (sequential fetching based on dependencies); parallel fetching for independent data; prefetching data before navigation or user actions; polling for real-time updates; infinite scrolling and pagination; and optimistic updates for immediate UI feedback. Error handling typically involves catch blocks or try/catch in async functions, with standardized error states and appropriate user feedback. Effective data fetching strategies consider caching policies, request deduplication, error retry logic, and offline support based on application requirements.",
    tips: [
      "Compare different data fetching libraries and their use cases",
      "Demonstrate error handling and loading state management",
      "Explain caching strategies and their performance implications",
      "Discuss server-side rendering considerations for data fetching",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "data-fetching",
      "api-integration",
    ],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-24",
    question:
      "What is the React reconciliation algorithm and how does it work?",
    category: "technical",
    difficulty: "hard",
    type: "technical",
    sampleAnswer:
      "React's reconciliation algorithm, often called the 'diffing' algorithm, efficiently updates the DOM to match the most recent React component tree. When a component's state or props change, React creates a new virtual DOM tree and compares it with the previous one to determine the minimal set of changes needed to update the actual DOM. The algorithm uses several heuristics to achieve O(n) complexity instead of the theoretical O(n³) for optimal tree comparison. First, it compares elements of the same type: if the type changes (e.g., from div to span), React rebuilds the entire subtree rather than attempting to match children. For elements of the same type, React updates only the changed attributes. For component elements, React updates props and calls lifecycle methods or reruns the component function. When comparing child lists, React by default compares children in order and applies insertions or deletions where they differ. This can be inefficient for reordered lists, which is why the key prop is critical—it helps React identify which items have moved rather than being recreated. Keys should be stable, predictable, and unique among siblings. The reconciliation process is synchronous in traditional React, though newer concurrent features allow it to be interrupted and resumed. Understanding this algorithm helps developers write more efficient React code by using keys properly, keeping component trees stable, and avoiding unnecessary rerenders with techniques like React.memo, PureComponent, or shouldComponentUpdate.",
    tips: [
      "Explain the role of keys in efficient list reconciliation",
      "Compare React's diffing approach with traditional virtual DOM libraries",
      "Discuss Fiber architecture's impact on reconciliation",
      "Provide examples of common reconciliation pitfalls",
    ],
    tags: ["react", "frontend", "javascript", "reconciliation", "virtual-dom"],
    estimatedTime: 5,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
  {
    id: "react-25",
    question: "How do you ensure accessibility (a11y) in React applications?",
    category: "technical",
    difficulty: "medium",
    type: "technical",
    sampleAnswer:
      "Ensuring accessibility in React applications requires both following general web accessibility principles and addressing React-specific considerations. Semantic HTML remains foundational—using appropriate elements like <button>, <nav>, and <article> rather than generic <div> elements with JavaScript handlers. ARIA attributes supplement HTML when needed, with aria-label, aria-expanded, and other attributes providing context to assistive technologies. React's declarative nature helps manage dynamic content accessibility, but developers must explicitly handle focus management during route changes or when content updates substantially. The useRef hook combined with element.focus() can programmatically move focus when needed. For forms, associate labels with inputs explicitly, provide error messages linked to their fields, and ensure keyboard navigability. Managing focus traps for modals and dropdowns is essential—libraries like focus-trap-react help contain focus within modal dialogs. Color contrast, text sizing, and responsive design support users with visual impairments. Testing tools include automated checkers like jest-axe for component tests, eslint-plugin-jsx-a11y for catching common issues during development, and browser extensions like axe DevTools or WAVE. Manual testing with screen readers (NVDA, VoiceOver) and keyboard navigation remains crucial. Component libraries like Chakra UI, Reach UI, or Adobe React Spectrum provide accessible foundations but require proper implementation. Progressive enhancement ensures functionality with JavaScript disabled, and appropriate page titles and landmarks improve navigation for screen reader users.",
    tips: [
      "Explain the relationship between semantic HTML and React components",
      "Demonstrate focus management techniques for SPAs",
      "Discuss testing approaches for accessibility in React",
      "Address common accessibility issues in React patterns",
    ],
    tags: [
      "react",
      "frontend",
      "javascript",
      "accessibility",
      "inclusive-design",
    ],
    estimatedTime: 4,
    industry: ["tech"],
    practiceCount: 0,
    successRate: 0,
  },
];
