[33mcommit 5650d78bd38ad2f8546913e3527abb7ec5c86239[m[33m ([m[1;31morigin/cursor/fix-inconsistent-string-question-approaches-164c[m[33m)[m
Author: Cursor Agent <cursoragent@cursor.com>
Date:   Fri Aug 22 07:57:32 2025 +0000

    Enhance string questions with multi-language solutions and detailed approaches
    
    Co-authored-by: akshayjuluri6704 <akshayjuluri6704@gmail.com>

[1mdiff --git a/src/components/InterviewPrep/bank/enhanced/StringQuestions.ts b/src/components/InterviewPrep/bank/enhanced/StringQuestions.ts[m
[1mindex bd97969..559843c 100644[m
[1m--- a/src/components/InterviewPrep/bank/enhanced/StringQuestions.ts[m
[1m+++ b/src/components/InterviewPrep/bank/enhanced/StringQuestions.ts[m
[36m@@ -10,23 +10,25 @@[m [mexport const enhancedStringQuestions: Question[] = [[m
     difficulty: "easy",[m
     type: "technical",[m
     approach:[m
[31m-      "To determine if two strings are anagrams, we need to verify they contain the exact same characters with the same frequencies. We can use three main strategies: sorting both strings and comparing equality (easiest but less efficient), using a hash map to track character frequencies (optimal for general cases), or using a fixed-size array for lowercase letters (most efficient for restricted character sets).",[m
[32m+[m[32m      "Multiple approaches available: 1) Sorting (O(n log n) time, O(n) space): Sort both strings and compare for equality. 2) Hash Map (O(n) time, O(n) space): Count character frequencies using a map. 3) Fixed Array (O(n) time, O(1) space): Use fixed-size array for limited character sets like lowercase letters. The hash map approach is optimal for general cases, while fixed array is most efficient for constrained character sets.",[m
     codeImplementation: [[m
       {[m
[31m-        language: "typescript",[m
[31m-        explanation:[m
[31m-          "Sorting Approach: This solution sorts both strings and compares them for equality. If they're anagrams, sorting will result in identical strings. Time complexity is O(n log n) due to sorting, and space complexity is O(n) for the sorted copies.",[m
[31m-        code: `function isAnagram(s: string, t: string): boolean {[m
[32m+[m[32m        language: "TypeScript",[m
[32m+[m[32m        code: `// Approach 1: Sorting[m
[32m+[m[32m// Time: O(n log n), Space: O(n)[m
[32m+[m[32mfunction isAnagram(s: string, t: string): boolean {[m
     if (s.length !== t.length) return false;[m
     [m
     return s.split('').sort().join('') === t.split('').sort().join('');[m
 }`,[m
[32m+[m[32m        explanation:[m
[32m+[m[32m          "Sort both strings and compare for equality. Simple but less efficient due to sorting overhead.",[m
       },[m
       {[m
[31m-        language: "typescript",[m
[31m-        explanation:[m
[31m-          "Character Count with Hash Map: We use a map to count occurrences of each character in the first string, then decrement counts for each character in the second string. If all characters match exactly, the map will be empty at the end. Time complexity is O(n) and space complexity is O(k) where k is the character set size.",[m
[31m-        code: `function isAnagramCount(s: string, t: string): boolean {[m
[32m+[m[32m        language: "TypeScript",[m
[32m+[m[32m        code: `// Approach 2: Hash Map (Optimal)[m
[32m+[m[32m// Time: O(n), Space: O(n)[m
[32m+[m[32mfunction isAnagramCount(s: string, t: string): boolean {[m
     if (s.length !== t.length) return false;[m
     [m
     const charCount = new Map<string, number>();[m
[36m@@ -47,12 +49,14 @@[m [mexport const enhancedStringQuestions: Question[] = [[m
     [m
     return charCount.size === 0;[m
 }`,[m
[32m+[m[32m        explanation:[m
[32m+[m[32m          "Count character frequencies using a map. Optimal time complexity for general character sets.",[m
       },[m
       {[m
[31m-        language: "typescript",[m
[31m-        explanation:[m
[31m-          "Array Count for ASCII Letters: For lowercase letter constraints, we can use a fixed-size array (length 26) for counting. This approach is more memory-efficient than a hash map for restricted character sets. We increment counts for first string chars and decrement for second string chars. Time complexity is O(n) and space complexity is O(1).",[m
[31m-        code: `function isAnagramArray(s: string, t: string): boolean {[m
[32m+[m[32m        language: "TypeScript",[m
[32m+[m[32m        code: `// Approach 3: Fixed Array (Most efficient for constrained sets)[m
[32m+[m[32m// Time: O(n), Space: O(1)[m
[32m+[m[32mfunction isAnagramArray(s: string, t: string): boolean {[m
     if (s.length !== t.length) return false;[m
     [m
     const count = new Array(26).fill(0);[m
[36m@@ -64,6 +68,77 @@[m [mexport const enhancedStringQuestions: Question[] = [[m
     [m
     return count.every(c => c === 0);[m
 }`,[m
[32m+[m[32m        explanation:[m
[32m+[m[32m          "Use fixed-size array for counting. Most efficient for constrained character sets like lowercase letters.",[m
[32m+[m[32m      },[m
[32m+[m[32m      {[m
[32m+[m[32m        language: "Java",[m
[32m+[m[32m        code: `// Approach 1: Sorting[m
[32m+[m[32m// Time: O(n log n), Space: O(n)[m
[32m+[m[32mpublic boolean isAnagram(String s, String t) {[m
[32m+[m[32m    if (s.length() != t.length()) return false;[m
[32m+[m[41m    [m
[32m+[m[32m    char[] sArray = s.toCharArray();[m
[32m+[m[32m    char[] tArray = t.toCharArray();[m
[32m+[m[41m    [m
[32m+[m[32m    Arrays.sort(sArray);[m
[32m+[m[32m    Arrays.sort(tArray);[m
[32m+[m[41m    [m
[32m+[m[32m    return Arrays.equals(sArray, tArray);[m
[32m+[m[32m}`,[m
[32m+[m[32m        explanation:[m
[32m+[m[32m          "Sort both strings and compare for equality. Simple but less efficient due to sorting overhead.",[m
[32m+[m[32m      },[m
[32m+[m[32m      {[m
[32m+[m[32m        language: "Java",[m
[32m+[m[32m        code: `// Approach 2: Hash Map (Optimal)[m
[32m+[m[32m// Time: O(n), Space: O(n)[m
[32m+[m[32mpublic boolean isAnagramCount(String s, String t) {[m
[32m+[m[32m    if (s.length() != t.length()) return false;[m
[32m+[m[41m    [m
[32m+[m[32m    Map<Character, Integer> charCount = new HashMap<>();[m
[32m+[m[41m    [m
[32m+[m[32m    // Count characters in s[m
[32m+[m[32m    for (char c : s.toCharArray()) {[m
[32m+[m[32m        charCount.put(c, charCount.getOrDefault(c, 0) + 1);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Subtract characters in t[m
[32m+[m[32m    for (char c : t.toCharArray()) {[m
[32m+[m[32m        if (!charCount.containsKey(c)) return false;[m
[32m+[m[32m        charCount.put(c, charCount.get(c) - 1);[m
[32m+[m[32m        if (charCount.get(c) == 0) {[m
[32m+[m[32m            charCount.remove(c);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    return charCount.isEmpty();[m
[32m+[m[32m}`,[m
[32m+[m[32m        explanation:[m
[32m+[m[32m          "Count character frequencies using a map. Optimal time complexity for general character sets.",[m
[32m+[m[32m      },[m
[32m+[m[32m      {[m
[32m+[m[32m        language: "Java",[m
[32m+[m[32m        code: `// Approach 3: Fixed Array (Most efficient for constrained sets)[m
[32m+[m[32m// Time: O(n), Space: O(1)[m
[32m+[m[32mpublic boolean isAnagramArray(String s, String t) {[m
[32m+[m[32m    if (s.length() != t.length()) return false;[m
[32m+[m[41m    [m
[32m+[m[32m    int[] count = new int[26];[m
[32m+[m[41m    [m
[32m+[m[32m    for (int i = 0; i < s.length(); i++) {[m
[32m+[m[32m        count[s.charAt(i) - 'a']++;[m
[32m+[m[32m        count[t.charAt(i) - 'a']--;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    for (int c : count) {[m
[32m+[m[32m        if (c != 0) return false;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    return true;[m
[32m+[m[32m}`,[m
[32m+[m[32m        explanation:[